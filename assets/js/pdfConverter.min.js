        // UI helpers (dropdown, mobile sidebar, stacked buttons)
        (function () {
            const moreToggle = document.getElementById("more-dropdown-toggle");
            const moreMenu = document.getElementById("more-dropdown-menu");
            if (moreToggle) {
                moreToggle.addEventListener("click", (e) => {
                    e.stopPropagation();
                    moreMenu.classList.toggle("open");
                });
                document.addEventListener("click", () => {
                    moreMenu.classList.remove("open");
                });
            }

            const mobileHamburger = document.getElementById("mobile-hamburger");
            const mobileSidebar = document.getElementById("mobile-sidebar");
            const mobileSidebarClose = document.getElementById(
                "mobile-sidebar-close"
            );
            const overlay = document.getElementById("overlay");

            const mobileMoreToggle = document.getElementById("mobile-more-toggle");
            const mobileMoreList = document.getElementById("mobile-more-list");
            const mobileMoreIcon = document.getElementById("mobile-more-icon");

            if (mobileMoreToggle) {
                mobileMoreToggle.addEventListener("click", () => {
                    const isOpen = mobileMoreList.classList.toggle("open");
                    mobileMoreIcon.classList.toggle("fa-chevron-down", !isOpen);
                    mobileMoreIcon.classList.toggle("fa-chevron-up", isOpen);
                });
            }

            mobileHamburger &&
                mobileHamburger.addEventListener("click", () => {
                    mobileSidebar.classList.add("open");
                    mobileSidebar.setAttribute("aria-hidden", "false");
                    overlay.classList.add("open");
                    document.body.classList.add("panel-open");
                });
            mobileSidebarClose &&
                mobileSidebarClose.addEventListener("click", () => {
                    mobileSidebar.classList.remove("open");
                    mobileSidebar.setAttribute("aria-hidden", "true");
                    overlay.classList.remove("open");
                    document.body.classList.remove("panel-open");
                });

            overlay &&
                overlay.addEventListener("click", () => {
                    mobileSidebar && mobileSidebar.classList.remove("open");
                    document.querySelector(".settings-panel") &&
                        document
                            .querySelector(".settings-panel")
                            .classList.remove("open");
                    overlay.classList.remove("open");
                    document.body.classList.remove("panel-open");
                });

            document.addEventListener("keydown", (e) => {
                if (e.key === "Escape") {
                    document.getElementById("more-dropdown-menu") &&
                        document
                            .getElementById("more-dropdown-menu")
                            .classList.remove("open");
                    mobileSidebar && mobileSidebar.classList.remove("open");
                    document.querySelector(".settings-panel") &&
                        document
                            .querySelector(".settings-panel")
                            .classList.remove("open");
                    overlay && overlay.classList.remove("open");
                    document.body.classList.remove("panel-open");
                }
            });
        })();

        // ===== app JS =====
        const state = {
            images: [],
            orientation: "portrait",
            pageSize: "a4",
            margin: "none",
            merge: true,
            pdfBlob: null,
            zipBlob: null,
        };

        const fileInput = document.getElementById("file-input");
        const addMoreInput = document.getElementById("add-more-input");
        const thumbnailsContainer = document.getElementById(
            "thumbnails-container"
        );
        const convertBtnMobile = document.getElementById("convert-btn-mobile");
        const convertBtnDesktop = document.getElementById("convert-btn-desktop");
        const downloadPdfBtn = document.getElementById("download-pdf");
        const backToEditBtn = document.getElementById("back-to-edit");
        const convertMoreBtn = document.getElementById("convert-more");
        const addMoreBtnRef = document.getElementById("add-more-btn");
        const pageSizeSelect = document.getElementById("page-size-select");
        const mergeCheckbox = document.getElementById("merge-pdf");
        const orientationPortrait = document.getElementById(
            "orientation-portrait"
        );
        const orientationLandscape = document.getElementById(
            "orientation-landscape"
        );
        const marginNone = document.getElementById("margin-none");
        const marginSmall = document.getElementById("margin-small");
        const marginBig = document.getElementById("margin-big");
        const dropArea = document.getElementById("drop-area");
        const settingsPanelRef = document.querySelector(".settings-panel");
        const overlayRef = document.getElementById("overlay");
        const openSettingsBtnRef = document.getElementById("open-settings");
        const closeSettingsBtnRef = document.getElementById("close-settings");
        const convertingOverlay = document.getElementById("converting-overlay");
        const ringFg = document.getElementById("ring-fg");
        const ringPercentEl = document.getElementById("ring-percent");
        const ringStatusEl = document.getElementById("ring-status");

        let dragSrcIndex = null;
        const wait = (ms) => new Promise((r) => setTimeout(r, ms));
        document.addEventListener("DOMContentLoaded", init);
        function init() {
            setupListeners();
            marginNone && marginNone.classList.add("selected");
            marginSmall && marginSmall.classList.remove("selected");
            marginBig && marginBig.classList.remove("selected");
        }

        function setupListeners() {
            fileInput && fileInput.addEventListener("change", handleFileSelect);
            addMoreInput &&
                addMoreInput.addEventListener("change", handleAddMoreFiles);
            ["dragenter", "dragover", "dragleave", "drop"].forEach(
                (evt) =>
                    dropArea && dropArea.addEventListener(evt, preventDefaults, false)
            );
            ["dragenter", "dragover"].forEach(
                (evt) => dropArea && dropArea.addEventListener(evt, highlight, false)
            );
            ["dragleave", "drop"].forEach(
                (evt) =>
                    dropArea && dropArea.addEventListener(evt, unhighlight, false)
            );
            dropArea && dropArea.addEventListener("drop", handleDrop, false);

            orientationPortrait &&
                orientationPortrait.addEventListener("click", () =>
                    handleOptionSelect("orientation", "portrait")
                );
            orientationLandscape &&
                orientationLandscape.addEventListener("click", () =>
                    handleOptionSelect("orientation", "landscape")
                );
            marginNone &&
                marginNone.addEventListener("click", () =>
                    handleOptionSelect("margin", "none")
                );
            marginSmall &&
                marginSmall.addEventListener("click", () =>
                    handleOptionSelect("margin", "small")
                );
            marginBig &&
                marginBig.addEventListener("click", () =>
                    handleOptionSelect("margin", "big")
                );

            pageSizeSelect &&
                pageSizeSelect.addEventListener("change", (e) => {
                    state.pageSize = e.target.value;
                    renderThumbnails();
                });
            mergeCheckbox &&
                mergeCheckbox.addEventListener("change", (e) => {
                    state.merge = e.target.checked;
                });

            convertBtnMobile &&
                convertBtnMobile.addEventListener("click", handleConvert);
            convertBtnDesktop &&
                convertBtnDesktop.addEventListener("click", handleConvert);

            downloadPdfBtn &&
                downloadPdfBtn.addEventListener("click", handleDownload);
            backToEditBtn &&
                backToEditBtn.addEventListener("click", () => {
                    document.getElementById("download-screen").classList.add("hidden");
                    document
                        .getElementById("preview-screen")
                        .classList.remove("hidden");
                });
            convertMoreBtn && convertMoreBtn.addEventListener("click", resetApp);

            addMoreBtnRef &&
                addMoreBtnRef.addEventListener(
                    "click",
                    () => addMoreInput && addMoreInput.click()
                );

            openSettingsBtnRef &&
                openSettingsBtnRef.addEventListener("click", () => {
                    settingsPanelRef && settingsPanelRef.classList.add("open");
                    overlayRef && overlayRef.classList.add("open");
                    document.body.classList.add("panel-open");
                });
            closeSettingsBtnRef &&
                closeSettingsBtnRef.addEventListener("click", () => {
                    settingsPanelRef && settingsPanelRef.classList.remove("open");
                    overlayRef && overlayRef.classList.remove("open");
                    document.body.classList.remove("panel-open");
                });
            overlayRef &&
                overlayRef.addEventListener("click", () => {
                    settingsPanelRef && settingsPanelRef.classList.remove("open");
                    overlayRef && overlayRef.classList.remove("open");
                    document.body.classList.remove("panel-open");
                });
        }

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        function highlight() {
            dropArea && dropArea.classList.add("border-red-500", "bg-red-50");
        }
        function unhighlight() {
            dropArea && dropArea.classList.remove("border-red-500", "bg-red-50");
        }
        function handleDrop(e) {
            const dt = e.dataTransfer;
            handleFiles(dt.files);
        }

        function handleFileSelect(e) {
            handleFiles(e.target.files);
            e.target.value = "";
        }
        function handleAddMoreFiles(e) {
            handleFiles(e.target.files);
            e.target.value = "";
        }

        function handleFiles(files) {
            if (!files || files.length === 0) return;
            const imageFiles = Array.from(files).filter(
                (f) => f.type && f.type.startsWith && f.type.startsWith("image/")
            );
            if (imageFiles.length === 0) {
                alert("Please select image files only.");
                return;
            }
            let processed = 0;
            imageFiles.forEach((file) => {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    // Store original mime type along with dataUrl
                    state.images.push({
                        file,
                        dataUrl: ev.target.result,
                        rotation: 0,
                        mime: file.type || "",
                    });
                    processed++;
                    if (processed === imageFiles.length) showPreviewScreen();
                };
                reader.readAsDataURL(file);
            });
        }

        function showPreviewScreen() {
            document.getElementById("upload-screen").classList.add("hidden");
            document.getElementById("preview-screen").classList.remove("hidden");
            renderThumbnails();
        }

        function renderThumbnails() {
            thumbnailsContainer && (thumbnailsContainer.innerHTML = "");
            const pageDimensions = getPageDimensions();
            const aspectRatio = pageDimensions.height / pageDimensions.width;
            const width = 160;
            const height = width * aspectRatio;

            const marginSizes = { none: 0, small: 12, big: 36 };
            const margin = marginSizes[state.margin];

            state.images.forEach((image, index) => {
                const container = document.createElement("div");
                container.className = "thumbnail-container relative";
                container.draggable = true;
                container.dataset.index = index;
                container.style.minHeight = height + 64 + "px";
                container.style.cursor = "grab";

                container.addEventListener("dragstart", (e) => {
                    dragSrcIndex = index;
                    container.classList.add("dragging");
                    e.dataTransfer.effectAllowed = "move";
                    try {
                        const imgEl = container.querySelector("img");
                        const canvas = document.createElement("canvas");
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext("2d");
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        const radius = 8;
                        ctx.save();
                        roundRectPath(ctx, 0, 0, canvas.width, canvas.height, radius);
                        ctx.clip();
                        const naturalW = imgEl.naturalWidth || imgEl.width;
                        const naturalH = imgEl.naturalHeight || imgEl.height;
                        let sx = 0,
                            sy = 0,
                            sWidth = naturalW,
                            sHeight = naturalH;
                        const imgRatio = naturalW / naturalH;
                        const boxRatio = canvas.width / canvas.height;
                        if (imgRatio > boxRatio) {
                            const newWidth = naturalH * boxRatio;
                            sx = (naturalW - newWidth) / 2;
                            sWidth = newWidth;
                        } else {
                            const newHeight = naturalW / boxRatio;
                            sy = (naturalH - newHeight) / 2;
                            sHeight = newHeight;
                        }
                        ctx.drawImage(
                            imgEl,
                            sx,
                            sy,
                            sWidth,
                            sHeight,
                            0,
                            0,
                            canvas.width,
                            canvas.height
                        );
                        ctx.restore();
                        e.dataTransfer.setDragImage(
                            canvas,
                            canvas.width / 2,
                            canvas.height / 2
                        );
                    } catch (err) {
                        const tiny = document.createElement("canvas");
                        tiny.width = 1;
                        tiny.height = 1;
                        e.dataTransfer.setDragImage(tiny, 0, 0);
                    }
                    e.dataTransfer.setData("text/plain", "");
                });

                container.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    container.classList.add("drag-over");
                    e.dataTransfer.dropEffect = "move";
                });
                container.addEventListener("dragleave", () => {
                    container.classList.remove("drag-over");
                });
                container.addEventListener("drop", (e) => {
                    e.preventDefault();
                    container.classList.remove("drag-over");
                    const destIndex = index;
                    if (dragSrcIndex === null) return;
                    if (destIndex !== dragSrcIndex) {
                        const [moved] = state.images.splice(dragSrcIndex, 1);
                        const insertIndex =
                            destIndex > dragSrcIndex ? destIndex : destIndex;
                        state.images.splice(insertIndex, 0, moved);
                    }
                    dragSrcIndex = null;
                    document
                        .querySelectorAll(".thumbnail-container.dragging")
                        .forEach((el) => el.classList.remove("dragging"));
                    renderThumbnails();
                });
                container.addEventListener("dragend", () => {
                    dragSrcIndex = null;
                    container.classList.remove("dragging");
                    document
                        .querySelectorAll(".thumbnail-container")
                        .forEach((el) => el.classList.remove("drag-over"));
                });

                const inner = document.createElement("div");
                inner.className = "paper-page mb-3";
                inner.style.width = width + "px";
                inner.style.height = height + "px";
                inner.style.margin = "0 auto";
                inner.style.position = "relative";
                inner.style.overflow = "hidden";
                inner.style.padding = margin + "px";

                const imgEl = document.createElement("img");
                imgEl.src = image.dataUrl;
                imgEl.alt = image.file.name;
                imgEl.loading = "lazy";
                imgEl.style.transform = `rotate(${image.rotation}deg)`;
                imgEl.style.maxWidth = "100%";
                imgEl.style.maxHeight = "100%";
                imgEl.style.display = "block";

                const actions = document.createElement("div");
                actions.className = "thumbnail-actions";
                actions.style.top = "8px";
                actions.style.right = "8px";

                const rotateBtn = document.createElement("div");
                rotateBtn.className = "action-btn rotate-btn";
                rotateBtn.innerHTML = '<i class="fas fa-redo text-gray-700"></i>';
                rotateBtn.addEventListener("click", (ev) => {
                    ev.stopPropagation();
                    rotateImage(index);
                });

                const removeBtn = document.createElement("div");
                removeBtn.className = "action-btn remove-btn";
                removeBtn.innerHTML = '<i class="fas fa-times text-gray-700"></i>';
                removeBtn.addEventListener("click", (ev) => {
                    ev.stopPropagation();
                    removeImage(index);
                });

                actions.appendChild(rotateBtn);
                actions.appendChild(removeBtn);
                inner.appendChild(imgEl);
                inner.appendChild(actions);

                const meta = document.createElement("div");
                meta.className = "text-center mt-2";
                meta.innerHTML = `<p class="text-sm font-medium truncate">${image.file.name
                    }</p><p class="text-xs text-gray-500">${formatFileSize(
                        image.file.size
                    )}</p>`;

                container.appendChild(inner);
                container.appendChild(meta);
                thumbnailsContainer && thumbnailsContainer.appendChild(container);
            });
        }

        function roundRectPath(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
        }

        function getPageDimensions() {
            const pageSizes = {
                a4: [210, 297],
                letter: [215.9, 279.4],
                legal: [215.9, 355.6],
            };
            const [w, h] = pageSizes[state.pageSize];
            return state.orientation === "portrait"
                ? { width: w, height: h }
                : { width: h, height: w };
        }
        function rotateImage(index) {
            state.images[index].rotation =
                (state.images[index].rotation + 90) % 360;
            renderThumbnails();
        }
        function removeImage(index) {
            state.images.splice(index, 1);
            if (state.images.length === 0) {
                document.getElementById("preview-screen").classList.add("hidden");
                document.getElementById("upload-screen").classList.remove("hidden");
            } else renderThumbnails();
        }
        function handleOptionSelect(type, value) {
            if (type === "orientation") {
                state.orientation = value;
                orientationPortrait.classList.toggle(
                    "selected",
                    value === "portrait"
                );
                orientationLandscape.classList.toggle(
                    "selected",
                    value === "landscape"
                );
            } else if (type === "margin") {
                state.margin = value;
                marginNone.classList.toggle("selected", value === "none");
                marginSmall.classList.toggle("selected", value === "small");
                marginBig.classList.toggle("selected", value === "big");
            }
            renderThumbnails();
        }

        async function handleConvert() {
            if (state.images.length === 0) {
                alert("Please add at least one image.");
                return;
            }
            const duration = 5000;
            showConvertingOverlay();
            const animPromise = runRingAnimation(duration);
            const genPromise = generatePdfOrZip();
            try {
                await Promise.all([animPromise, genPromise]);
                hideConvertingOverlay();
                document.getElementById("preview-screen").classList.add("hidden");
                document.getElementById("download-screen").classList.remove("hidden");
            } catch (err) {
                hideConvertingOverlay();
                console.error("Conversion error:", err);
                alert("An error occurred while converting. Please try again.");
            }
        }

        function runRingAnimation(durationMs) {
            return new Promise((resolve) => {
                const radius = 52;
                const circumference = 2 * Math.PI * radius;
                ringFg && (ringFg.style.strokeDasharray = circumference.toString());
                let start = performance.now();
                function tick(now) {
                    const elapsed = now - start;
                    const t = Math.min(1, elapsed / durationMs);
                    const percent = Math.floor(t * 100);
                    const offset = circumference * (1 - t);
                    ringFg && (ringFg.style.strokeDashoffset = offset.toString());
                    ringPercentEl && (ringPercentEl.textContent = percent + "%");
                    if (percent < 35)
                        ringStatusEl && (ringStatusEl.textContent = "Uploading");
                    else ringStatusEl && (ringStatusEl.textContent = "Converting");
                    if (t < 1) requestAnimationFrame(tick);
                    else {
                        ringFg && (ringFg.style.strokeDashoffset = "0");
                        ringPercentEl && (ringPercentEl.textContent = "100%");
                        ringStatusEl && (ringStatusEl.textContent = "Converting");
                        setTimeout(resolve, 250);
                    }
                }
                requestAnimationFrame(tick);
            });
        }

        function showConvertingOverlay() {
            ringFg && (ringFg.style.transition = "none");
            const radius = 52;
            const circumference = 2 * Math.PI * radius;
            ringFg && (ringFg.style.strokeDasharray = circumference.toString());
            ringFg && (ringFg.style.strokeDashoffset = circumference.toString());
            void ringFg && ringFg.offsetWidth;
            ringFg && (ringFg.style.transition = "stroke-dashoffset 140ms linear");
            ringPercentEl && (ringPercentEl.textContent = "0%");
            ringStatusEl && (ringStatusEl.textContent = "Uploading");
            convertingOverlay && (convertingOverlay.style.display = "flex");
        }
        function hideConvertingOverlay() {
            convertingOverlay && (convertingOverlay.style.display = "none");
        }

        // generatePdfOrZip updated to support all image formats and choose proper embedding format
        async function generatePdfOrZip() {
            state.pdfBlob = null;
            state.zipBlob = null;
            const { jsPDF } = window.jspdf;
            const pageSizes = {
                a4: [210, 297],
                letter: [215.9, 279.4],
                legal: [215.9, 355.6],
            };
            const marginSizes = { none: 0, small: 10, big: 25 };
            const margin = marginSizes[state.margin];
            const baseSize = pageSizes[state.pageSize];
            const [pageW_mm0, pageH_mm0] = baseSize;
            const pageWidth_mm =
                state.orientation === "portrait" ? pageW_mm0 : pageH_mm0;
            const pageHeight_mm =
                state.orientation === "portrait" ? pageH_mm0 : pageW_mm0;

            if (state.merge) {
                const pdf = new jsPDF({
                    orientation: state.orientation,
                    unit: "mm",
                    format: state.pageSize,
                });
                for (let i = 0; i < state.images.length; i++) {
                    if (i > 0) pdf.addPage();
                    const imageObj = state.images[i];
                    const { dataUrlForPdf, drawWidthMM, drawHeightMM, embedFormat } =
                        await prepareImageForPdf(
                            imageObj,
                            pageWidth_mm,
                            pageHeight_mm,
                            margin
                        );
                    const x = (pageWidth_mm - drawWidthMM) / 2;
                    const y = (pageHeight_mm - drawHeightMM) / 2;
                    // embedFormat is 'JPEG' or 'PNG'
                    pdf.addImage(
                        dataUrlForPdf,
                        embedFormat,
                        x,
                        y,
                        drawWidthMM,
                        drawHeightMM
                    );
                }
                state.pdfBlob = pdf.output("blob");
            } else {
                const zip = new JSZip();
                for (let i = 0; i < state.images.length; i++) {
                    const pdf = new jsPDF({
                        orientation: state.orientation,
                        unit: "mm",
                        format: state.pageSize,
                    });
                    const imageObj = state.images[i];
                    const { dataUrlForPdf, drawWidthMM, drawHeightMM, embedFormat } =
                        await prepareImageForPdf(
                            imageObj,
                            pageWidth_mm,
                            pageHeight_mm,
                            margin
                        );
                    const x = (pageWidth_mm - drawWidthMM) / 2;
                    const y = (pageHeight_mm - drawHeightMM) / 2;
                    pdf.addImage(
                        dataUrlForPdf,
                        embedFormat,
                        x,
                        y,
                        drawWidthMM,
                        drawHeightMM
                    );
                    const pdfBlob = pdf.output("blob");
                    const nameWithoutExt = imageObj.file.name.replace(/\.[^/.]+$/, "");
                    zip.file(`${nameWithoutExt}.pdf`, pdfBlob);
                }
                state.zipBlob = await zip.generateAsync({ type: "blob" });
            }
        }

        // prepareImageForPdf: rasterizes the image to canvas, rotates if needed, chooses embed format
        function prepareImageForPdf(
            imageObj,
            pageWidth_mm,
            pageHeight_mm,
            margin_mm
        ) {
            return new Promise((resolve) => {
                const img = new Image();
                // ensure crossOrigin is anonymous to allow canvas conversion when possible
                img.crossOrigin = "anonymous";
                img.onload = () => {
                    let imgW = img.width,
                        imgH = img.height;
                    const rotation = imageObj.rotation % 360;
                    const rotate90 = rotation === 90 || rotation === 270;
                    const logicalW = rotate90 ? imgH : imgW;
                    const logicalH = rotate90 ? imgW : imgH;

                    const contentW_mm = pageWidth_mm - margin_mm * 2;
                    const contentH_mm = pageHeight_mm - margin_mm * 2;

                    // We need to compute ratio using pixels <-> mm. We will scale such that image fits content area
                    // Use a pixels-per-mm anchor: compute ratio that maps logical pixel dimensions to mm drawing size
                    // We'll compute a drawing scale: drawWidthMM = logicalW * scale; choose scale = min(contentW_mm / logicalW, contentH_mm / logicalH)
                    const ratio = Math.min(
                        contentW_mm / logicalW,
                        contentH_mm / logicalH
                    );
                    const drawWidthMM = logicalW * ratio;
                    const drawHeightMM = logicalH * ratio;

                    // Create canvas and draw rotated image into it
                    // Use canvas sized to the image's intrinsic pixels (rotate accordingly)
                    const canvas = document.createElement("canvas");
                    const ctx = canvas.getContext("2d");

                    if (rotate90) {
                        canvas.width = imgH;
                        canvas.height = imgW;
                        if (rotation === 90) {
                            ctx.translate(canvas.width, 0);
                            ctx.rotate(Math.PI / 2);
                        } else {
                            ctx.translate(0, canvas.height);
                            ctx.rotate(-Math.PI / 2);
                        }
                        ctx.drawImage(img, 0, 0);
                    } else if (rotation === 180) {
                        canvas.width = imgW;
                        canvas.height = imgH;
                        ctx.translate(canvas.width, canvas.height);
                        ctx.rotate(Math.PI);
                        ctx.drawImage(img, 0, 0);
                    } else {
                        canvas.width = imgW;
                        canvas.height = imgH;
                        ctx.drawImage(img, 0, 0);
                    }

                    // Decide embed format: prefer PNG if the original was PNG (lossless) or if it has alpha
                    // We'll detect alpha by creating a 1x1 sample (cheap approach) - but simpler: if original mime === 'image/png' or original mime === 'image/svg+xml', use PNG
                    let embedFormat = "JPEG";
                    let dataUrlForPdf;

                    // If the image likely has alpha (PNG), embed as PNG to preserve transparency; otherwise JPEG
                    const origMime = (imageObj.mime || "").toLowerCase();
                    const wantsPng =
                        origMime === "image/png" ||
                        origMime === "image/svg+xml" ||
                        (origMime === "image/webp" && hasAlphaCheck(canvas));

                    // NOTE: Some browsers may not support reading webp via jsPDF; we rasterize to PNG or JPEG via canvas and instruct jsPDF accordingly.
                    if (wantsPng) {
                        try {
                            dataUrlForPdf = canvas.toDataURL("image/png");
                            embedFormat = "PNG";
                        } catch (err) {
                            // fallback to JPEG
                            dataUrlForPdf = canvas.toDataURL("image/jpeg", 0.92);
                            embedFormat = "JPEG";
                        }
                    } else {
                        // JPEG with good quality
                        dataUrlForPdf = canvas.toDataURL("image/jpeg", 0.92);
                        embedFormat = "JPEG";
                    }

                    resolve({ dataUrlForPdf, drawWidthMM, drawHeightMM, embedFormat });
                };
                img.onerror = () => {
                    // fallback: use provided dataUrl and fit full page area
                    resolve({
                        dataUrlForPdf: imageObj.dataUrl,
                        drawWidthMM: pageWidth_mm - margin_mm * 2,
                        drawHeightMM: pageHeight_mm - margin_mm * 2,
                        embedFormat: "JPEG",
                    });
                };
                img.src = imageObj.dataUrl;
            });
        }

        // helper to quickly check if canvas contains alpha (simple heuristic: sample a few pixels)
        // Not always 100% accurate but helps choose PNG for images with transparency.
        function hasAlphaCheck(canvas) {
            try {
                const ctx = canvas.getContext("2d");
                if (!ctx) return false;
                const w = Math.min(10, canvas.width);
                const h = Math.min(10, canvas.height);
                const imgd = ctx.getImageData(0, 0, w, h).data;
                for (let i = 3; i < imgd.length; i += 4) {
                    if (imgd[i] < 255) return true;
                }
            } catch (e) {
                // cross-origin or non-readable canvas -> assume no alpha
                return false;
            }
            return false;
        }

        function handleDownload() {
            const now = new Date();
            const timestamp = `${now.getFullYear()}${String(
                now.getMonth() + 1
            ).padStart(2, "0")}${String(now.getDate()).padStart(2, "0")}-${String(
                now.getHours()
            ).padStart(2, "0")}${String(now.getMinutes()).padStart(2, "0")}${String(
                now.getSeconds()
            ).padStart(2, "0")}`;
            if (state.merge && state.pdfBlob) {
                saveAs(state.pdfBlob, `images-to-pdf-${timestamp}.pdf`);
            } else if (!state.merge && state.zipBlob) {
                saveAs(state.zipBlob, `images-to-pdf-${timestamp}.zip`);
            } else alert("No file available to download. Please convert first.");
            downloadPdfBtn.innerHTML = "Downloading...";
            setTimeout(() => {
                downloadPdfBtn.innerHTML = "Download PDF";
            }, 1000);
        }

        function resetApp() {
            state.images = [];
            state.orientation = "portrait";
            state.pageSize = "a4";
            state.margin = "none";
            state.merge = true;
            state.pdfBlob = null;
            state.zipBlob = null;
            orientationPortrait && orientationPortrait.classList.add("selected");
            orientationLandscape &&
                orientationLandscape.classList.remove("selected");
            marginNone && marginNone.classList.add("selected");
            marginSmall && marginSmall.classList.remove("selected");
            marginBig && marginBig.classList.remove("selected");
            pageSizeSelect && (pageSizeSelect.value = "a4");
            mergeCheckbox && (mergeCheckbox.checked = true);
            document.getElementById("download-screen").classList.add("hidden");
            document.getElementById("upload-screen").classList.remove("hidden");
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return "0 Bytes";
            const k = 1024;
            const sizes = ["Bytes", "KB", "MB", "GB"];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
        }